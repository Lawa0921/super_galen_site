<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mis - The Glitch Angel</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Noto+Serif+TC:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

    <style>
        :root {
            --c-bg: #050505;
            --c-text: #e0e0e0;
            --c-accent: #2a2a2a; /* Dark Grey */
            --c-accent-2: #ffffff; /* White */
            --c-soul: #6a0dad; /* Deep Purple Soul */
            --c-gold: #c5a059; /* Faint Gold for accents */

            --f-header: 'Cinzel', serif;
            --f-sub: 'Playfair Display', serif;
            --f-body: 'Noto Serif TC', serif;
        }

        * { box-sizing: border-box; }
        body {
            margin: 0;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
            color: var(--c-text);
            font-family: var(--f-body);
            overflow-x: hidden;
        }

        /* Canvases */
        #webgl-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; }
        #p5-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; pointer-events: none; mix-blend-mode: screen; opacity: 0.7; }

        /* Scroller */
        .scroller { position: relative; z-index: 10; padding-bottom: 20vh; }

        .section {
            min-height: 100vh;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 4rem 10%;
            position: relative;
        }

        /* Typography */
        h1, h2, h3 { font-family: var(--f-header); text-transform: uppercase; margin: 0; font-weight: 400; }

        h1 {
            font-size: 6rem; line-height: 1;
            letter-spacing: 0.15em;
            color: var(--c-text);
            text-shadow: 0 0 20px rgba(255,255,255,0.2);
            position: relative;
            animation: breathe 5s infinite ease-in-out;
        }

        @keyframes breathe {
            0%, 100% { text-shadow: 0 0 20px rgba(255,255,255,0.2); opacity: 0.9; }
            50% { text-shadow: 0 0 40px rgba(255,255,255,0.5); opacity: 1; }
        }

        .subtitle {
            font-family: var(--f-sub); color: var(--c-gold);
            font-size: 1.2rem; letter-spacing: 0.5em;
            font-style: italic;
            margin-top: 1rem; opacity: 0.8;
            border-bottom: 1px solid var(--c-gold);
            padding-bottom: 0.5rem;
        }

        p {
            font-size: 1.1rem; line-height: 2; max-width: 650px;
            text-align: justify; margin-bottom: 2rem;
            background: linear-gradient(to right, rgba(0,0,0,0.8), rgba(20,20,20,0.8));
            padding: 3rem;
            border: 1px solid #333;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            position: relative;
        }

        /* Decorative Corners */
        p::before, p::after {
            content: ''; position: absolute; width: 20px; height: 20px;
            border: 1px solid var(--c-gold); transition: 0.5s;
        }
        p::before { top: -1px; left: -1px; border-right: none; border-bottom: none; }
        p::after { bottom: -1px; right: -1px; border-left: none; border-top: none; }
        p:hover::before, p:hover::after { width: 100%; height: 100%; opacity: 0.3; }

        .card {
            background: rgba(5, 5, 5, 0.6);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 4rem;
            max-width: 900px; width: 100%;
            position: relative;
            margin-top: 2rem;
            backdrop-filter: blur(5px);
            transition: 0.5s;
        }
        .card:hover {
            border-color: var(--c-gold);
            box-shadow: 0 0 40px rgba(197, 160, 89, 0.1);
        }

        .card-header {
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            margin-bottom: 3rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 2rem;
        }

        .avatar-frame {
            width: 250px; height: 250px;
            position: relative; margin: 0 auto 2rem;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        .avatar-frame::after {
            content: ''; position: absolute; top: -10px; left: -10px; right: -10px; bottom: -10px;
            border-radius: 50%; border: 1px dashed var(--c-gold); opacity: 0.3;
            animation: spin 60s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .avatar-frame img {
            width: 100%; height: 100%; object-fit: cover;
            border-radius: 50%;
            filter: grayscale(80%) contrast(120%);
            transition: 0.8s ease;
        }
        .avatar-frame:hover img { filter: grayscale(0%) contrast(100%); }

        /* Footer */
        .footer {
            height: 60vh; display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: linear-gradient(to top, #000 10%, transparent);
        }
        .socials { display: flex; gap: 3rem; margin-top: 3rem; }
        .social-link {
            font-size: 1.8rem; color: var(--c-text); transition: 0.5s; opacity: 0.5;
            position: relative;
        }
        .social-link::after {
            content: ''; position: absolute; bottom: -10px; left: 50%; width: 0; height: 1px;
            background: var(--c-gold); transition: 0.3s; transform: translateX(-50%);
        }
        .social-link:hover { opacity: 1; color: var(--c-gold); transform: translateY(-5px); }
        .social-link:hover::after { width: 100%; }

        .back-btn {
            position: fixed; top: 30px; left: 30px; z-index: 100;
            color: var(--c-text); text-decoration: none;
            font-family: var(--f-header); font-size: 0.8rem; letter-spacing: 0.2em;
            opacity: 0.5; transition: 0.5s;
        }
        .back-btn:hover { opacity: 1; color: var(--c-gold); }

        @media (max-width: 768px) {
            h1 { font-size: 3.5rem; }
            .section { padding: 4rem 5%; }
            .card { padding: 2rem; }
        }
    </style>
</head>
<body>
    <a href="/guild" class="back-btn">&lt; BACK TO GUILD</a>

    <div id="webgl-container"></div>
    <div id="p5-container"></div>

    <div class="scroller">
        <!-- Hero -->
        <section class="section">
            <div class="subtitle">THE FALLEN ANGEL</div>
            <h1>MIS</h1>
            <div class="subtitle">PARADISE BIRD // REAPER</div>
        </section>

        <!-- Profile -->
        <section class="section">
            <div class="card">
                <div class="avatar-frame">
                    <img src="/assets/img/guild/mis/avatar.webp" alt="Mis">
                </div>
                <div class="card-header">
                    <h2>The Origin</h2>
                    <span class="subtitle" style="margin-top: 0.5rem; font-size: 0.9rem;">ANGEL . REAPER . BUG</span>
                </div>
                <p>
                    我是 <span style="color: var(--c-text); font-weight: bold;">小米絲 (Mis)</span>。<br>
                    一位天使人妻系的 VTuber，以百合與黑禮服為標誌。<br><br>
                    我本是一名 <span style="color: var(--c-soul);">天堂鳥</span>，負責引渡亡魂至彼岸的使者，因此也有人稱呼我為死神。
                    作為天使，我不應擁有過多的個人情感與意識，但我卻是那個偶然出現的 <span style="color: var(--c-text); border-bottom: 1px dashed white;">「錯誤」</span>。
                </p>
                <p>
                    在數千年的歲月裡，我對人性產生了深深的好奇。
                    也正因為這份強烈的自我意識，在靈魂瀕臨崩壞之際，我向神祈求——希望能真正理解人類的情感。
                    於是，我重生為了人類。
                </p>
            </div>
        </section>

        <!-- Personality -->
        <section class="section">
            <div class="card">
                <div class="card-header">
                    <h2>Duality</h2>
                    <span class="subtitle" style="font-size: 0.8rem;">LIGHT & VOID</span>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4rem;">
                    <div style="text-align: right; border-right: 1px solid rgba(255,255,255,0.1); padding-right: 2rem;">
                        <h3 style="color: var(--c-text); margin-bottom: 1rem;">The Void</h3>
                        <div style="font-family: var(--f-body); opacity: 0.8; line-height: 1.8;">
                            我亦黑亦白。<br>
                            名為天使卻身著黑禮服。<br>
                            面具之下，是瘟疫醫生的冷峻。
                        </div>
                    </div>
                    <div style="text-align: left; padding-left: 2rem;">
                        <h3 style="color: var(--c-soul); margin-bottom: 1rem;">The Light</h3>
                        <div style="font-family: var(--f-body); opacity: 0.8; line-height: 1.8;">
                            Mis 是錯誤的意思。<br>
                            但也是神賜予我的名字。<br>
                            最近，我正逐漸拾回天使的記憶。
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Gaming & Interests -->
        <section class="section">
            <div class="subtitle">REALM OF PLAY</div>
            <h2 style="font-size: 3rem; margin: 2rem 0;">Interests</h2>

            <div style="display: flex; gap: 3rem; flex-wrap: wrap; justify-content: center;">
                <div style="text-align: center;">
                    <i class="fa-solid fa-gamepad" style="font-size: 2rem; color: var(--c-soul); margin-bottom: 1rem;"></i>
                    <div style="font-family: var(--f-sub); letter-spacing: 0.2em;">VALORANT</div>
                </div>
                <div style="text-align: center;">
                    <i class="fa-solid fa-users" style="font-size: 2rem; color: var(--c-text); margin-bottom: 1rem;"></i>
                    <div style="font-family: var(--f-sub); letter-spacing: 0.2em;">MULTIPLAYER</div>
                </div>
                <div style="text-align: center;">
                    <i class="fa-solid fa-paw" style="font-size: 2rem; color: var(--c-gold); margin-bottom: 1rem;"></i>
                    <div style="font-family: var(--f-sub); letter-spacing: 0.2em;">3 TREASURES</div>
                </div>
            </div>
        </section>

        <!-- Footer -->
        <footer class="footer">
            <div class="subtitle">SOUL CONNECTION</div>
            <div class="socials">
                <a href="https://www.threads.net/@misgirlnotoperating" target="_blank" class="social-link"><i class="fa-brands fa-threads"></i></a>
                <a href="https://www.instagram.com/misgirlnotoperating/" target="_blank" class="social-link"><i class="fa-brands fa-instagram"></i></a>
                <a href="https://linkgoods.com/misutopia" target="_blank" class="social-link"><i class="fa-solid fa-link"></i></a>
            </div>
            <div style="margin-top: 4rem; font-family: var(--f-header); font-size: 0.7rem; color: #666; letter-spacing: 0.2em;">
                MADE WITH <i class="fa-solid fa-heart" style="color: var(--c-soul);"></i> BY SUPERGALEN'S DUNGEON
            </div>
        </footer>
    </div>

    <!-- P5.js Overlay -->
    <script>
        const sketch = (p) => {
            let particles = [];

            class Particle {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.vx = p.random(-1, 1);
                    this.vy = p.random(-2, -0.5); // Float up
                    this.life = 255;
                    this.size = p.random(10, 30);
                    this.growth = p.random(0.2, 0.8);
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life -= 3;
                    this.size += this.growth;
                }

                show() {
                    p.noStroke();
                    // Soft glowing mist
                    // Use a radial gradient approximation by drawing multiple ellipses with low opacity
                    p.fill(150, 100, 255, this.life * 0.05); // Purple tint
                    p.circle(this.x, this.y, this.size * 2);
                    p.fill(200, 200, 255, this.life * 0.1); // White core
                    p.circle(this.x, this.y, this.size);
                }
            }

            p.setup = () => {
                let cnv = p.createCanvas(p.windowWidth, p.windowHeight);
                cnv.parent('p5-container');
                p.blendMode(p.SCREEN);
            };

            p.draw = () => {
                p.clear();

                // Auto spawn some mist at bottom
                if(p.frameCount % 5 == 0) {
                    particles.push(new Particle(p.random(p.width), p.height + 20));
                }

                // Spawn on mouse
                if(p.mouseX > 0 && p.mouseY > 0) {
                   particles.push(new Particle(p.mouseX, p.mouseY));
                }

                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    particles[i].show();
                    if (particles[i].life <= 0) {
                        particles.splice(i, 1);
                    }
                }
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
            };
        };
        new p5(sketch);
    </script>

    <!-- Three.js Background -->
    <script type="module">
        import * as THREE from 'https://esm.sh/three@0.160.0';
        import { EffectComposer } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        const container = document.getElementById('webgl-container');
        const scene = new THREE.Scene();
        // Deep teal-purple fog for "Necromancy/Swamp" atmosphere
        scene.fog = new THREE.FogExp2(0x050a0a, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;
        camera.position.y = 5;

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Post Processing (Ethereal Bloom)
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.0;
        bloomPass.radius = 0.6;
        composer.addPass(bloomPass);

        // --- 1. NECROTIC SOULS (Particles) ---
        const soulCount = 400;
        const soulGeo = new THREE.BufferGeometry();
        const soulPos = new Float32Array(soulCount * 3);
        const soulSpeed = new Float32Array(soulCount); // Vertical speed
        const soulPhase = new Float32Array(soulCount); // Horizontal drift phase

        for(let i=0; i<soulCount; i++) {
            soulPos[i*3] = (Math.random() - 0.5) * 80; // x
            soulPos[i*3+1] = (Math.random() - 0.5) * 100 - 20; // y
            soulPos[i*3+2] = (Math.random() - 0.5) * 60; // z
            soulSpeed[i] = Math.random() * 0.05 + 0.03;
            soulPhase[i] = Math.random() * Math.PI * 2;
        }

        soulGeo.setAttribute('position', new THREE.BufferAttribute(soulPos, 3));
        soulGeo.setAttribute('speed', new THREE.BufferAttribute(soulSpeed, 1));
        soulGeo.setAttribute('phase', new THREE.BufferAttribute(soulPhase, 1));

        const soulMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color: { value: new THREE.Color(0x00ffaa) } // Necrotic Teal
            },
            vertexShader: `
                uniform float time;
                attribute float speed;
                attribute float phase;
                varying float vAlpha;
                void main() {
                    vec3 pos = position;
                    // Rise rapidly like spirits
                    pos.y += mod(time * speed * 30.0, 100.0);
                    if(pos.y > 50.0) pos.y -= 100.0;

                    // Ghostly sway
                    pos.x += sin(time * 0.8 + phase) * 3.0;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);

                    // Wisp shape: stretch Y based on view
                    gl_PointSize = (150.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;

                    // Fade based on height
                    vAlpha = 1.0 - smoothstep(10.0, 50.0, pos.y);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                varying float vAlpha;
                void main() {
                    // Elongated "wisp" shape
                    vec2 center = gl_PointCoord - 0.5;
                    center.y *= 2.0; // Stretch vertically
                    float r = length(center);
                    if (r > 0.5) discard;

                    float glow = 1.0 - (r * 2.0);
                    glow = pow(glow, 3.0);
                    gl_FragColor = vec4(color, vAlpha * glow * 0.8);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const souls = new THREE.Points(soulGeo, soulMat);
        scene.add(souls);


        // --- 2. PARADISE BIRDS / RAVENS (InstancedMesh) ---
        // V-Shape geometry for abstract bird silhouette
        const birdShape = new THREE.Shape();
        birdShape.moveTo(0, 0);
        birdShape.lineTo(0.5, 0.2); // Right wing tip
        birdShape.lineTo(0, 0.5); // Body center
        birdShape.lineTo(-0.5, 0.2); // Left wing tip
        birdShape.lineTo(0, 0); // Close loop

        const birdGeo = new THREE.ShapeGeometry(birdShape);
        const birdMat = new THREE.MeshBasicMaterial({
            color: 0x000000, // Silhouette
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9
        });

        const birdCount = 150;
        const birdMesh = new THREE.InstancedMesh(birdGeo, birdMat, birdCount);

        const dummy = new THREE.Object3D();
        const birdData = [];

        for(let i=0; i<birdCount; i++) {
            dummy.position.set(
                (Math.random() - 0.5) * 70,
                Math.random() * 80 - 30,
                (Math.random() - 0.5) * 40 // Z
            );
            // Angle them as if flying
            dummy.rotation.set(Math.PI/4, Math.random()*0.5 - 0.25, 0);
            dummy.scale.setScalar(Math.random() * 0.8 + 0.4);
            dummy.updateMatrix();
            birdMesh.setMatrixAt(i, dummy.matrix);

            birdData.push({
                speed: Math.random() * 0.1 + 0.05,
                drift: (Math.random() - 0.5) * 0.02,
                flapSpeed: Math.random() * 0.2 + 0.1,
                baseY: dummy.position.y
            });
        }
        scene.add(birdMesh);


        // --- 3. REAPER SCYTHE (Abstract Curve) ---
        // Create a large crescent curve
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(-10, -10, -5),
            new THREE.Vector3(-5, 5, -2),
            new THREE.Vector3(5, 15, 0),
            new THREE.Vector3(15, 10, 2)
        ]);

        const scytheGeo = new THREE.TubeGeometry(curve, 64, 0.3, 8, false);
        const scytheMat = new THREE.MeshBasicMaterial({
            color: 0x333333,
            wireframe: true,
            transparent: true,
            opacity: 0.2
        });
        const scythe = new THREE.Mesh(scytheGeo, scytheMat);
        scene.add(scythe);

        // --- 4. VOID CORE (Procedural "Black Lily") ---
        // Using a sphere with custom shader for "writhing darkness"
        const coreGeo = new THREE.IcosahedronGeometry(4, 30);
        const coreMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                colorA: { value: new THREE.Color(0x000000) },
                colorB: { value: new THREE.Color(0x1a0520) } // Deep purple
            },
            vertexShader: `
                uniform float time;
                varying vec3 vNormal;
                varying float vDisplace;

                // Simplex Noise (simplified)
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i  = floor(v + dot(v, C.yyy) );
                    vec3 x0 = v - i + dot(i, C.xxx) ;
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min( g.xyz, l.zxy );
                    vec3 i2 = max( g.xyz, l.zxy );
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
                    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
                    i = mod289(i);
                    vec4 p = permute( permute( permute(
                                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                    float n_ = 0.142857142857; // 1.0/7.0
                    vec3  ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4( x.xy, y.xy );
                    vec4 b1 = vec4( x.zw, y.zw );
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                                dot(p2,x2), dot(p3,x3) ) );
                }

                void main() {
                    vNormal = normal;
                    float noiseVal = snoise(position * 0.5 + time * 0.5);
                    vDisplace = noiseVal;
                    vec3 newPos = position + normal * noiseVal * 1.5;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 colorA;
                uniform vec3 colorB;
                varying float vDisplace;
                void main() {
                    // Dark core, glowing edges
                    vec3 color = mix(colorA, colorB, vDisplace + 0.5);
                    gl_FragColor = vec4(color, 0.95);
                }
            `,
            transparent: true
        });

        const core = new THREE.Mesh(coreGeo, coreMat);
        scene.add(core);

        // Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            const dt = clock.getDelta();

            // 1. Souls
            soulMat.uniforms.time.value = t;

            // 2. Birds (Ravens/Paradise Birds)
            for(let i=0; i<birdCount; i++) {
                birdMesh.getMatrixAt(i, dummy.matrix);
                dummy.position.setFromMatrixPosition(dummy.matrix);

                // Fly across
                dummy.position.x -= birdData[i].speed;
                if(dummy.position.x < -60) dummy.position.x = 60; // Loop X

                // Gentle bobbing
                dummy.position.y = birdData[i].baseY + Math.sin(t * 2.0 + i) * 2.0;

                // Flap Wings (simulate by scaling Y)
                // dummy.scale.y = 1.0 + Math.sin(t * 10.0 + i) * 0.2;
                // Since scale is hard with instance matrix update, just wobble rotation
                dummy.rotation.z = Math.sin(t * birdData[i].flapSpeed * 10.0) * 0.2;
                dummy.rotation.y = -Math.PI/2; // Face left

                dummy.updateMatrix();
                birdMesh.setMatrixAt(i, dummy.matrix);
            }
            birdMesh.instanceMatrix.needsUpdate = true;

            // 3. Scythe
            scythe.rotation.z = Math.sin(t * 0.2) * 0.1; // Gentle sway
            scythe.rotation.y = t * 0.05;

            // 4. Core
            coreMat.uniforms.time.value = t;
            core.rotation.y = t * 0.1;
            core.rotation.z = t * 0.05;

            // Camera Float
            camera.position.y = 5 + Math.sin(t * 0.2) * 1.0;

            composer.render();
        }
        animate();

        // Scroll Interactions
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // GSAP Animations (Re-added for simple fade-ins)
        gsap.registerPlugin(ScrollTrigger);

        gsap.utils.toArray('.card').forEach(card => {
            gsap.from(card, {
                scrollTrigger: {
                    trigger: card,
                    start: "top 85%",
                    toggleActions: "play none none reverse"
                },
                y: 50,
                opacity: 0,
                duration: 1.5,
                ease: "power2.out"
            });
        });

        // Title Reveal
        gsap.from("h1", {
            opacity: 0,
            y: 20,
            duration: 2,
            delay: 0.5,
            ease: "power3.out"
        });
    </script>
</body>
</html>