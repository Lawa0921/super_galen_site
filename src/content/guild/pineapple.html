<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>È≥≥Ê¢®ËÄÅÂ∏´ÁöÑÊïôÂ≠∏Êó•Ë®ò | Sunny Math Journal</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC:wght@300;400;700&family=Patrick+Hand&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        :root {
            --paper: #FDF5E6;
            --ink: #2F4F4F;
            --wood: #5D4037;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: #2c1e16;
            color: var(--ink);
            font-family: 'LXGW WenKai TC', sans-serif;
            overflow: hidden;
            width: 100vw; height: 100vh;
        }

        #canvas-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0;
        }

        /* UI Layer */
        .ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; pointer-events: none;
        }

        .nav-bar {
            position: absolute; top: 2rem; left: 2rem;
            pointer-events: auto;
        }
        .back-link {
            text-decoration: none; color: #FDF5E6; font-size: 1.2rem; font-weight: bold;
            display: flex; align-items: center; gap: 0.5rem;
            transition: opacity 0.3s;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .back-link:hover { opacity: 0.8; }

        /* Loading Overlay */
        .loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #2c1e16;
            z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s;
            color: #FDF5E6;
        }
        .loading-screen.hidden { opacity: 0; pointer-events: none; }
        .loading-text { font-size: 1.5rem; margin-top: 1rem; font-family: 'Patrick Hand', cursive; }

        /* Footer Hint */
        .footer-hint {
            position: absolute; bottom: 2rem; width: 100%; text-align: center;
            color: #FDF5E6; font-family: 'LXGW WenKai TC', sans-serif;
            opacity: 0.7; font-size: 1rem; pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        /* Image Preloader (Hidden) */
        #assets { display: none; }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <i class="fa-solid fa-book-open fa-3x fa-bounce"></i>
        <div class="loading-text">Êï¥ÁêÜÂõûÊÜ∂‰∏≠...</div>
    </div>

    <div id="canvas-container"></div>

    <div class="ui-layer">
        <nav class="nav-bar">
            <a href="index.html" class="back-link"><i class="fa-solid fa-arrow-left"></i> GUILD</a>
        </nav>
        <div class="footer-hint">
            <i class="fa-solid fa-hand-pointer"></i> ÈªûÊìäÈ†ÅÈù¢ÈÇäÁ∑£ÈÄ≤Ë°åÁøªÈ†Å
        </div>
    </div>

    <!-- Hidden Assets -->
    <div id="assets">
        <img id="img-avatar" src="../assets/img/guild/pineapple/avatar.webp">
        <img id="img-g1" src="../assets/img/guild/pineapple/gallery_1.webp">
        <img id="img-g2" src="../assets/img/guild/pineapple/gallery_2.webp">
        <img id="img-g3" src="../assets/img/guild/pineapple/gallery_3.webp">
        <img id="img-g4" src="../assets/img/guild/pineapple/gallery_4.webp">
        <img id="img-g5" src="../assets/img/guild/pineapple/gallery_5.webp">
        <img id="img-g6" src="../assets/img/guild/pineapple/gallery_6.webp">
        <img id="img-g7" src="../assets/img/guild/pineapple/gallery_7.webp">
        <img id="img-g8" src="../assets/img/guild/pineapple/gallery_8.webp">
        <img id="img-g9" src="../assets/img/guild/pineapple/gallery_9.webp">
    </div>

    <script>
        // --- Configuration ---
        const config = {
            colors: {
                bg: 0x2c1e16, // Dark wood table
                paper: 0xFDF5E6, // Old Lace
                cover: 0x8B4513, // Leather
                spine: 0x3E2723
            },
            book: {
                width: 12,
                height: 16,
                depth: 0.1, // Page thickness
                segments: 20
            }
        };

        // --- State ---
        let state = {
            currentPage: 0,
            totalPages: 0, // Will be set dynamically
            isFlipping: false,
            pages: [] // Array of Page Meshes
        };

        // --- Init Three.js ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(config.colors.bg);
        // Fog for atmosphere
        scene.fog = new THREE.FogExp2(0x1a100c, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 15, 12); // High angle shot
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        // Desk Lamp (Spotlight)
        const spotLight = new THREE.SpotLight(0xffeeb1, 1.2); // Warm light
        spotLight.position.set(5, 15, 5);
        spotLight.angle = 0.6;
        spotLight.penumbra = 0.5;
        spotLight.decay = 2;
        spotLight.distance = 50;
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        scene.add(spotLight);

        // --- Environment (Desk) ---
        const deskGeo = new THREE.PlaneGeometry(50, 50);
        const deskMat = new THREE.MeshStandardMaterial({
            color: 0x3e2723,
            roughness: 0.9,
            side: THREE.DoubleSide
        });
        const desk = new THREE.Mesh(deskGeo, deskMat);
        desk.rotation.x = -Math.PI / 2;
        desk.position.y = -0.5;
        desk.receiveShadow = true;
        scene.add(desk);

        // --- Page Factory (Canvas Texture Generator) ---
        function createPageTexture(content, index) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1365; // ~3:4 Aspect Ratio
            const ctx = canvas.getContext('2d');

            // Background (Old Paper)
            ctx.fillStyle = '#FDF5E6';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Texture (Subtle Noise/Lines)
            ctx.strokeStyle = 'rgba(0,0,0,0.05)';
            ctx.lineWidth = 2;
            for(let y=100; y<canvas.height; y+=40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Margin Line
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.2)';
            ctx.beginPath();
            ctx.moveTo(100, 0);
            ctx.lineTo(100, canvas.height);
            ctx.stroke();

            // Page Number
            ctx.fillStyle = '#888';
            ctx.font = '30px "Patrick Hand"';
            ctx.textAlign = 'right';
            ctx.fillText(index + 1, canvas.width - 50, canvas.height - 50);

            // Content Drawing
            ctx.fillStyle = '#2F4F4F';
            ctx.textAlign = 'left';

            if (content.type === 'cover') {
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Border
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 10;
                ctx.strokeRect(50, 50, canvas.width-100, canvas.height-100);

                // Title
                ctx.fillStyle = '#FFD700';
                ctx.textAlign = 'center';
                ctx.font = 'bold 100px "LXGW WenKai TC"';
                ctx.fillText(content.title, canvas.width/2, 400);

                ctx.font = '50px "LXGW WenKai TC"';
                ctx.fillText(content.subtitle, canvas.width/2, 500);

                // Icon
                ctx.font = '150px "FontAwesome"';
                ctx.fillText('üçç', canvas.width/2, 800);

            } else if (content.type === 'intro') {
                // Photo (Polaroid Style)
                const img = document.getElementById(content.imgId);
                if(img) {
                    ctx.save();
                    ctx.translate(canvas.width/2, 350);
                    ctx.rotate(-0.05);
                    ctx.fillStyle = '#FFF';
                    ctx.shadowColor = 'rgba(0,0,0,0.2)';
                    ctx.shadowBlur = 20;
                    ctx.fillRect(-220, -260, 440, 520);
                    try {
                        ctx.drawImage(img, -200, -240, 400, 400);
                    } catch(e) {}
                    ctx.fillStyle = '#333';
                    ctx.font = '40px "Patrick Hand"';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 0;
                    ctx.fillText(content.caption, 0, 220);
                    ctx.restore();
                }

                // Handwritten Bio
                ctx.font = '40px "LXGW WenKai TC"';
                let y = 750;
                const lines = content.text.split('\n');
                lines.forEach(line => {
                    ctx.fillText(line, 150, y);
                    y += 60;
                });

            } else if (content.type === 'gallery') {
                ctx.fillStyle = '#333';
                ctx.font = 'bold 60px "LXGW WenKai TC"';
                ctx.fillText(content.title, 120, 150);

                // Grid of 2 photos
                const img1 = document.getElementById(content.imgIds[0]);
                const img2 = document.getElementById(content.imgIds[1]);

                if(img1) {
                     ctx.save();
                     ctx.translate(canvas.width/2, 450);
                     ctx.rotate(0.03);
                     ctx.fillStyle = '#FFF';
                     ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 15;
                     ctx.fillRect(-320, -220, 640, 440);
                     try { ctx.drawImage(img1, -300, -200, 600, 400); } catch(e){}
                     ctx.restore();
                }

                if(img2) {
                     ctx.save();
                     ctx.translate(canvas.width/2, 950);
                     ctx.rotate(-0.02);
                     ctx.fillStyle = '#FFF';
                     ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 15;
                     ctx.fillRect(-320, -220, 640, 440);
                     try { ctx.drawImage(img2, -300, -200, 600, 400); } catch(e){}
                     ctx.restore();
                }

                // Tape effect (visual only, simulated by rectangle)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillRect(canvas.width/2 - 50, 200, 100, 40);

            } else if (content.type === 'text') {
                ctx.font = 'bold 50px "LXGW WenKai TC"';
                ctx.fillText(content.title, 120, 150);

                ctx.font = '36px "LXGW WenKai TC"';
                let y = 250;
                const lines = content.text.split('\n');
                lines.forEach(line => {
                    ctx.fillText(line, 120, y);
                    y += 55;
                });

                // Stamp or Sticker
                if(content.stamp) {
                    ctx.font = '100px "serif"';
                    ctx.fillStyle = 'rgba(200, 50, 50, 0.6)';
                    ctx.save();
                    ctx.translate(canvas.width - 200, canvas.height - 200);
                    ctx.rotate(-0.3);
                    ctx.fillText(content.stamp, 0, 0);
                    ctx.restore();
                }
            } else if (content.type === 'end') {
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#FFD700';
                ctx.textAlign = 'center';
                ctx.font = 'bold 60px "LXGW WenKai TC"';
                ctx.fillText("ÊÑüË¨ùÊÇ®ÁöÑÈñ±ËÆÄ", canvas.width/2, 400);

                ctx.font = '40px "LXGW WenKai TC"';
                ctx.fillText("Ê≠°ËøéËÅØÁπ´ËàáÂêà‰Ωú", canvas.width/2, 500);

                // Contact Info
                ctx.fillStyle = '#FFF';
                ctx.font = '30px "sans-serif"';
                ctx.fillText("IG: @a_l_w_a_y_s_joy", canvas.width/2, 700);
                ctx.fillText("Threads: @a_l_w_a_y_s_joy", canvas.width/2, 750);

                ctx.font = '20px "LXGW WenKai TC"';
                ctx.fillText("Made with love by SuperGalen's Dungeon", canvas.width/2, 1200);
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return tex;
        }

        // --- Book Generation ---
        const bookGroup = new THREE.Group();
        scene.add(bookGroup);

        const pageGeo = new THREE.BoxGeometry(config.book.width, config.book.height, 0.05);
        pageGeo.translate(config.book.width / 2, 0, 0); // Pivot at spine (left edge)

        // Data Structure
        const bookContent = [
            { type: 'cover', title: 'È≥≥Ê¢®ËÄÅÂ∏´', subtitle: 'ÊïôÂ≠∏ÂõûÊÜ∂ÈåÑ' },
            { type: 'text', title: 'ÂâçË®Ä', text: 'ÈÄôÊòØ‰∏ÄÊú¨Ë®òÈåÑËëóÊïôÂ≠∏ËªåË∑°ÁöÑÁ≠ÜË®òÊú¨...\nÊØè‰∏ÄÈ†ÅÈÉΩÊâøËºâËëóËàáÂ≠©Â≠êÂÄëÁöÑÂõûÊÜ∂„ÄÇ\n\n"Áµ¶‰∫àÔºåÊòØ‰∏ÄÁîüÊúÄÊúâÊÑèÁæ©ÁöÑ‰∫ã„ÄÇ"\n\nË´ãÊÖ¢ÊÖ¢ÁøªÈñ±„ÄÇ', stamp: 'ÂàùÂøÉ' },
            { type: 'intro', imgId: 'img-avatar', caption: 'Hi! ÊàëÊòØÈ≥≥Ê¢®ËÄÅÂ∏´ üçç', text: 'Êï∏Â≠∏ËÄÅÂ∏´ / Ê°åÈÅäËÄÅÂ∏´ / Â•ßÊï∏ÊïôÁ∑¥\nÂÖ•Ë°å‰∏ÉÂπ¥„ÄÇ\n\nË∫´ÁÇ∫ÂîáÈ°éË£ÇÊÇ£ËÄÖÔºå\nÊàëÂèóÈÅéË®±Â§öÂπ´Âä©Ôºå\n‰πüÁ´ãÂøóË¶ÅÂõûÈ•ãÁ§æÊúÉ„ÄÇ\nÈÄô‰∏çÂÉÖÊòØÂ∑•‰ΩúÔºåÊòØÊàëÁöÑ‰ΩøÂëΩ„ÄÇ' },
            { type: 'text', title: 'ÊàëÁöÑ‰ΩøÂëΩ', text: 'ËÆìÂ≠©Â≠êÂÄë‰∏çÊáºÊÄïÊï∏Â≠∏Ôºå\nÁîöËá≥ÂñúÊ≠°‰∏äÊï∏Â≠∏ÔºÅ\n\nÁõÆÂâçÊ≠£Âú®Á±åÂÇôÂ•ßÊï∏Áè≠Ôºå\nÂ∏åÊúõÂ∏∂È†òÊõ¥Â§öÂ≠©Â≠êÁúãË¶ãÊï∏Â≠∏ÁöÑÊ®ÇË∂£„ÄÇ\n2024Âπ¥ÔºåÊàëÂÄëÂ∑≤Á∂ìÂú®ÂúòÈ´îË≥ΩÂá∫ÁôºÔºå\n‰∏¶Âú®ÂÄã‰∫∫Ë≥ΩÂ•™ÂæóÈäÄÈäÖÁçéÔºÅ', stamp: 'ÁÜ±Âø±' },
            { type: 'gallery', title: 'ÊïôÂ≠∏ÈªûÊª¥', imgIds: ['img-g1', 'img-g2'] },
            { type: 'gallery', title: 'Ê¥ªÂãïÁ¥ÄÈåÑ', imgIds: ['img-g3', 'img-g4'] },
            { type: 'gallery', title: 'Ê¶ÆËÄÄÊôÇÂàª', imgIds: ['img-g5', 'img-g6'] },
            { type: 'gallery', title: 'Èô™‰º¥ÊàêÈï∑', imgIds: ['img-g7', 'img-g8'] },
            { type: 'end' } // Back Cover
        ];

        // Ensure even number of pages (Cover is separate? No, let's treat all as sheets)
        // A "Sheet" has Front and Back.
        // Sheet 0: Front=Cover, Back=Page 1 (Left) -- Wait.
        // Standard Book:
        // Right Side opens.
        // Sheet 0: Front (Cover). Back (Empty or Intro).
        // Sheet 1: Front (Page 1). Back (Page 2).
        // Let's simplify: A stack of sheets.

        // We need pairs for front/back of each sheet.
        // Content 0 (Cover) -> Sheet 0 Front
        // Content 1 (Intro) -> Sheet 0 Back
        // Content 2 -> Sheet 1 Front
        // Content 3 -> Sheet 1 Back

        const sheets = [];

        function buildBook() {
            const numSheets = Math.ceil(bookContent.length / 2);

            for(let i=0; i<numSheets; i++) {
                const frontData = bookContent[i*2];
                const backData = bookContent[i*2 + 1];

                const frontTex = frontData ? createPageTexture(frontData, i*2) : null;
                const backTex = backData ? createPageTexture(backData, i*2+1) : null;

                const mat = [
                    new THREE.MeshStandardMaterial({ color: 0xFFFFFF }), // Right edge
                    new THREE.MeshStandardMaterial({ color: 0xFFFFFF }), // Left edge (spine)
                    new THREE.MeshStandardMaterial({ color: 0xFFFFFF }), // Top
                    new THREE.MeshStandardMaterial({ color: 0xFFFFFF }), // Bottom
                    new THREE.MeshStandardMaterial({ map: frontTex, roughness: 0.8 }), // Front
                    new THREE.MeshStandardMaterial({ map: backTex, roughness: 0.8 })  // Back
                ];

                const sheet = new THREE.Mesh(pageGeo, mat);
                sheet.position.z = -i * 0.06; // Stack depth
                sheet.rotation.y = 0; // All start closed (flat on right)

                // Initial State: Closed book lies on right side?
                // Let's say closed book cover is visible.
                // Cover is Sheet 0 Front.
                // We want to open it.

                sheet.userData = {
                    id: i,
                    isFlipped: false
                };

                bookGroup.add(sheet);
                sheets.push(sheet);
            }

            // Center the book slightly
            bookGroup.position.x = -3;
        }

        // --- Interaction Logic ---
        function flipNext() {
            if(state.isFlipping) return;
            // Find first non-flipped sheet
            const sheetToFlip = sheets.find(s => !s.userData.isFlipped);
            if(!sheetToFlip) return; // End of book

            state.isFlipping = true;

            // Animate
            // Rotate from 0 to -180 (Math.PI) roughly
            // Add a slight Z-arc to simulate lifting

            gsap.to(sheetToFlip.rotation, {
                y: -Math.PI + 0.1, // Slight angle so it doesn't z-fight with desk
                duration: 1.2,
                ease: "power2.inOut",
                onComplete: () => {
                    sheetToFlip.userData.isFlipped = true;
                    state.isFlipping = false;
                    // Adjust Z to stack on left?
                    // Simplified: Just rotation for now.
                    // To prevent Z-fighting on left stack, we might need to adjust Z dynamically during flip.
                }
            });

            // Z-Fighting Fix: Move active sheet slightly up during flip
            gsap.to(sheetToFlip.position, {
                z: 1,
                duration: 0.6,
                yoyo: true,
                repeat: 1,
                ease: "sine.out"
            });

            // Adjust Z order for stacking on left side
            // The first sheet flipped (Cover) should be at bottom of left stack.
            // But in 3D, if it rotates -180, its originally 'front' face faces down.
            // The 'back' face faces up.
            // Sheet 0 (Cover) flips. Back is Page 1.
            // Sheet 1 flips. Back is Page 3. It lands ON TOP of Sheet 0.
            // So Sheet 1 needs a HIGHER Z than Sheet 0 when flipped.

            // Current Z: Sheet 0 is at 0. Sheet 1 is at -0.06.
            // When flipped: Sheet 0 needs to be at LeftStackBase.
            // Sheet 1 needs to be at LeftStackBase + 0.06.

            // Let's try to animate Z to target.
            const targetZ = 0.06 * sheetToFlip.userData.id;
            // Wait, Sheet 0 is id 0. Sheet 1 is id 1.
            // If we flip Sheet 0, it goes to Left.
            // If we flip Sheet 1, it goes on top of Sheet 0.
            // So Z should INCREASE with ID on the left side.
            // Currently Z DECREASES with ID on right side (-0.06 * i).

            gsap.to(sheetToFlip.position, {
                z: targetZ,
                duration: 1.2,
                delay: 0 // Sync with rotation
            });
        }

        function flipPrev() {
            if(state.isFlipping) return;
            // Find last flipped sheet
            // We need to iterate backwards
            const reversed = [...sheets].reverse();
            const sheetToFlip = reversed.find(s => s.userData.isFlipped);
            if(!sheetToFlip) return; // Start of book

            state.isFlipping = true;

            gsap.to(sheetToFlip.rotation, {
                y: 0,
                duration: 1.0,
                ease: "power2.inOut",
                onComplete: () => {
                    sheetToFlip.userData.isFlipped = false;
                    state.isFlipping = false;
                }
            });

            // Arc
            gsap.to(sheetToFlip.position, {
                z: 1,
                duration: 0.5,
                yoyo: true,
                repeat: 1,
                ease: "sine.out"
            });

            // Return Z to original right-stack position
            const originalZ = -sheetToFlip.userData.id * 0.06;
            gsap.to(sheetToFlip.position, {
                z: originalZ,
                duration: 1.0
            });
        }

        // --- Init ---
        document.fonts.ready.then(() => {
            buildBook();
            document.getElementById('loadingScreen').classList.add('hidden');
        });

        // --- Inputs ---
        window.addEventListener('click', (e) => {
            if(e.target.closest('.nav-bar')) return;

            // Simple Logic: Click Right half to Next, Left half to Prev
            if(e.clientX > window.innerWidth / 2) {
                flipNext();
            } else {
                flipPrev();
            }
        });

        // Touch
        window.addEventListener('touchstart', (e) => {
            if(e.touches[0].clientX > window.innerWidth / 2) {
                flipNext();
            } else {
                flipPrev();
            }
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            if(document.hidden) return;
            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
