<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>塞趴卷 - 具現化系鍊金術師</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Noto+Serif+TC:wght@400;700;900&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

    <style>
        :root {
            --bg-color: #050505;
            --text-color: #f0f0f0;
            --gold: #FFD700;
            --cyan: #00FFFF;
            --dim: #444;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Noto Serif TC', serif;
            overflow-x: hidden;
        }

        #canvas-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
        }

        /* --- UI Overlay --- */
        .ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 2rem;
        }

        .header {
            display: flex; justify-content: space-between; align-items: flex-start;
        }

        .brand {
            font-family: 'Orbitron'; color: var(--gold); letter-spacing: 2px; font-size: 0.9rem;
            border: 1px solid var(--gold); padding: 5px 10px;
            pointer-events: auto; text-decoration: none;
        }

        .status {
            font-family: 'Orbitron'; color: var(--cyan); font-size: 0.8rem; text-align: right;
        }

        .footer {
            display: flex; justify-content: space-between; align-items: flex-end;
        }

        .social-link {
            pointer-events: auto; color: var(--text-color); text-decoration: none;
            font-family: 'Cinzel'; border-bottom: 1px solid var(--gold);
            transition: 0.3s;
        }
        .social-link:hover { color: var(--gold); }

        .progress-indicator {
            font-family: 'Orbitron'; font-size: 2rem; color: var(--dim);
        }

        /* --- Scroll Content --- */
        .scroll-track {
            height: 500vh; /* Long scroll for morphing */
        }

        .section-content {
            position: fixed;
            top: 50%; left: 10%;
            transform: translateY(-50%);
            width: 400px;
            pointer-events: none;
            opacity: 0;
        }

        .visible { pointer-events: auto; }

        h1 {
            font-family: 'Cinzel'; font-size: 4rem; margin-bottom: 1rem; color: var(--gold);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        h2 {
            font-family: 'Cinzel'; font-size: 2.5rem; margin-bottom: 1rem; color: var(--cyan);
        }

        p {
            font-size: 1.1rem; line-height: 1.8; margin-bottom: 1.5rem;
            text-shadow: 2px 2px 4px #000;
        }

        .highlight { color: var(--gold); font-weight: bold; }

        /* Hero Specific */
        .avatar-glitch {
            width: 100px; height: 100px;
            margin-bottom: 2rem;
            position: relative;
        }
        .avatar-glitch img {
            width: 100%; height: 100%; object-fit: cover;
            border-radius: 50%;
            border: 2px solid var(--gold);
        }

        /* Right aligned sections */
        .right-align {
            left: auto; right: 10%; text-align: right;
        }

    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="ui-layer">
        <div class="header">
            <a href="/guild/" class="brand">GUILD_HALL</a>
            <div class="status">
                SYSTEM: ONLINE<br>
                MATERIALIZATION: ACTIVE
            </div>
        </div>
        <div class="footer">
            <div class="progress-indicator">001</div>
            <div>
                <a href="https://www.threads.net/@spj.story" target="_blank" class="social-link">THREADS</a>
            </div>
        </div>
    </div>

    <!-- Scroll Trigger Track -->
    <div class="scroll-track"></div>

    <!-- Section 1: Hero -->
    <div class="section-content" id="sec-hero">
        <div class="avatar-glitch">
            <img src="/assets/img/guild/spj/avatar.webp" alt="SPJ">
        </div>
        <h1>塞趴卷 SPJ</h1>
        <p style="font-family: 'Orbitron'; letter-spacing: 2px; color: var(--cyan);">THE MATERIALIZER</p>
        <p>在 0 與 1 的混沌中，我是編織現實的架構師。</p>
    </div>

    <!-- Section 2: Intro (Left) -->
    <div class="section-content" id="sec-intro" style="top: 60%;">
        <h2>起源代碼</h2>
        <p>「想像力是虛無的，直到它被賦予結構。」</p>
        <p>我是一名<span class="highlight">軟體工程師</span>。但我更願意稱自己為具現化系鍊金術師。我的煉成陣是螢幕，我的咒語是代碼，我的目標是將腦海中的<span class="highlight">「文字小鎮」</span>具現為可觸碰的現實。</p>
    </div>

    <!-- Section 3: Guild (Right) -->
    <div class="section-content right-align" id="sec-guild">
        <h2>靈魂網絡</h2>
        <p>孤獨是創造者的詛咒。</p>
        <p>我夢想建立<span class="highlight">「塞趴卷冒險公會」</span>——一個現實世界的連結中樞。</p>
        <p>這是一個讓創造者們（冒險者）能夠集結、組隊、共享資源的節點。我們不再是孤島，而是星系。</p>
    </div>

    <!-- Section 4: Projects (Center) -->
    <div class="section-content" id="sec-projects" style="left: 50%; transform: translate(-50%, -50%); text-align: center; width: 600px;">
        <h2>具現化紀錄</h2>
        <div style="display: flex; gap: 2rem; justify-content: center; margin-top: 2rem;">
            <div>
                <div style="font-family: 'Orbitron'; font-size: 1.5rem; color: var(--gold);">01</div>
                <div style="font-weight: bold; margin-bottom: 0.5rem;">文字小鎮</div>
                <div style="font-size: 0.8rem; color: #aaa;">天書系統核心</div>
            </div>
            <div>
                <div style="font-family: 'Orbitron'; font-size: 1.5rem; color: var(--gold);">02</div>
                <div style="font-weight: bold; margin-bottom: 0.5rem;">冒險公會</div>
                <div style="font-size: 0.8rem; color: #aaa;">現實連結 Nexus</div>
            </div>
            <div>
                <div style="font-family: 'Orbitron'; font-size: 1.5rem; color: var(--gold);">03</div>
                <div style="font-weight: bold; margin-bottom: 0.5rem;">傳說紀錄</div>
                <div style="font-size: 0.8rem; color: #aaa;">吟遊詩人系統</div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Init ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // --- Particles & Morph Targets ---
        const pCount = 3000;
        const geometry = new THREE.BufferGeometry();

        // Define Shapes
        const posSphere = new Float32Array(pCount * 3);
        const posCube = new Float32Array(pCount * 3);
        const posTorus = new Float32Array(pCount * 3);
        const posChaos = new Float32Array(pCount * 3);

        // Helper: Random Point in Sphere
        function getSpherePoint(r) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            return [x, y, z];
        }

        // Helper: Random Point in Cube
        function getCubePoint(s) {
            return [
                (Math.random() - 0.5) * s,
                (Math.random() - 0.5) * s,
                (Math.random() - 0.5) * s
            ];
        }

        // Helper: Random Point in Torus
        function getTorusPoint(R, r) {
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI * 2;
            const x = (R + r * Math.cos(v)) * Math.cos(u);
            const y = (R + r * Math.cos(v)) * Math.sin(u);
            const z = r * Math.sin(v);
            return [x, y, z];
        }

        // Fill Arrays
        for(let i=0; i<pCount; i++) {
            const i3 = i*3;

            // Sphere (Hero)
            const s = getSpherePoint(10);
            posSphere[i3] = s[0]; posSphere[i3+1] = s[1]; posSphere[i3+2] = s[2];

            // Cube (Intro/Town)
            const c = getCubePoint(15);
            posCube[i3] = c[0]; posCube[i3+1] = c[1]; posCube[i3+2] = c[2];

            // Torus (Guild/Network)
            const t = getTorusPoint(10, 3);
            posTorus[i3] = t[0]; posTorus[i3+1] = t[1]; posTorus[i3+2] = t[2];

            // Chaos (Projects/Explosion)
            posChaos[i3] = (Math.random() - 0.5) * 50;
            posChaos[i3+1] = (Math.random() - 0.5) * 50;
            posChaos[i3+2] = (Math.random() - 0.5) * 50;
        }

        // Current Positions (Start as Sphere)
        const currentPos = new Float32Array(posSphere);
        geometry.setAttribute('position', new THREE.BufferAttribute(currentPos, 3));

        // Colors
        const colors = new Float32Array(pCount * 3);
        const color1 = new THREE.Color(0xFFD700);
        const color2 = new THREE.Color(0x00FFFF);

        for(let i=0; i<pCount; i++) {
            const mixed = color1.clone().lerp(color2, Math.random());
            colors[i*3] = mixed.r;
            colors[i*3+1] = mixed.g;
            colors[i*3+2] = mixed.b;
        }
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Interaction State ---
        let scrollProgress = 0;
        let targetShape = 0; // 0: Sphere, 1: Cube, 2: Torus, 3: Chaos

        // --- GSAP Scroll ---
        gsap.registerPlugin(ScrollTrigger);

        ScrollTrigger.create({
            trigger: ".scroll-track",
            start: "top top",
            end: "bottom bottom",
            onUpdate: (self) => {
                scrollProgress = self.progress;

                // Determine target shape based on scroll
                // 0-0.25: Sphere
                // 0.25-0.5: Cube
                // 0.5-0.75: Torus
                // 0.75-1.0: Chaos

                // Map progress to float index (0 to 3)
                targetShape = scrollProgress * 3;

                // Update Progress UI
                const p = Math.floor(scrollProgress * 100).toString().padStart(3, '0');
                document.querySelector('.progress-indicator').innerText = p;
            }
        });

        // Content Visibility
        const sections = ['#sec-hero', '#sec-intro', '#sec-guild', '#sec-projects'];
        sections.forEach((id, i) => {
            // Simple fade in/out based on scroll phases
            // 0: Hero, 1: Intro, 2: Guild, 3: Projects
            const start = i * 0.25;
            const end = (i + 1) * 0.25;

            // Use timeline to control opacity
            gsap.timeline({
                scrollTrigger: {
                    trigger: ".scroll-track",
                    start: `${start * 100}% top`,
                    end: `${end * 100}% top`,
                    scrub: 0.5
                }
            })
            .to(id, { opacity: 1, y: 0, duration: 0.2 })
            .to(id, { opacity: 0, y: -20, duration: 0.2 }, 0.8); // Fade out near end of segment
        });


        // --- Morph Logic ---
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // Animation Loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Rotate entire system
            particles.rotation.y = time * 0.1;

            // Calculate Current Morph
            // targetShape is float 0..3
            // If 0.5, we mix Shape 0 and Shape 1

            const positions = particles.geometry.attributes.position.array;

            let sourceArr, targetArr, mix;

            if (targetShape < 1) { // 0 -> 1 (Sphere -> Cube)
                sourceArr = posSphere;
                targetArr = posCube;
                mix = targetShape;
            } else if (targetShape < 2) { // 1 -> 2 (Cube -> Torus)
                sourceArr = posCube;
                targetArr = posTorus;
                mix = targetShape - 1;
            } else { // 2 -> 3 (Torus -> Chaos)
                sourceArr = posTorus;
                targetArr = posChaos;
                mix = targetShape - 2;
            }

            // Interpolate
            // Note: For 3000 particles, doing this every frame in JS is okay (~9000 ops)
            // Ideally use vertex shader, but JS is easier to setup here

            const speed = 0.1; // Smoothness factor

            for(let i=0; i<pCount*3; i++) {
                // Target position for this particle
                const tx = lerp(sourceArr[i], targetArr[i], mix);

                // Add noise/turbulence
                const noise = Math.sin(time * 5 + i) * 0.05;

                // Move current towards target
                // positions[i] += (tx - positions[i]) * speed; // Easing
                // Or Direct mapping for responsiveness to scroll
                positions[i] = tx + noise;
            }

            particles.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
